
use #root::data::Array;
use #root::debug::Show;
use #root::rng::Pcg32;
use #root::ops::arithmetic::Add;

pub struct Stream[T]((T, Stream[T]));

pub struct Send[T](~T);
pub mod Send {
  pub fn .send[T](Send[T](~send), data: T) {
    send = data;
  }

  pub fn .send_stream[T](&Send[Stream[T]](~send), data: T) {
    send = Stream(data, send);
  }

  pub fn .close_stream[T](Send[Stream[T]](send)) {
    unsafe::erase(send);
  }
}

pub struct Recv[T](T);
pub mod Recv {
  pub fn .recv[T](Recv[T](recv)) -> T {
    recv
  }

  pub fn .recv_stream[T](&Recv[Stream[T]](recv)) -> T {
    let data;
    Stream(data, recv) = recv;
    data
  }

  pub fn .close_stream[T](Recv[Stream[T]](recv)) {
    unsafe::erase(recv);
  }

  pub impl drop[T?]: Drop[Recv[T]];
}

pub struct Node(pub {
  page_rank: F32,
  in_edges: Array[Recv[Stream[F32]]],
  out_edges: Array[Send[Stream[F32]]],
});

pub mod Node {
  pub fn new(initial_page_rank: F32) -> Node {
    Node({ page_rank: initial_page_rank, in_edges: Array::empty, out_edges: Array::empty })
  }

  pub fn .link_to(
    &Node({ page_rank: _, in_edges: _, out_edges }),
    &Node({ page_rank: _, in_edges, out_edges: _ }),
  ) {
    let stream;
    out_edges.push_back(Send(~stream));
    in_edges.push_back(Recv(stream));
  }

  pub fn .process(
    &Node({ page_rank, in_edges, out_edges }),
    steps: N32,
    num_nodes: N32,
    damping: F32,
  ) {
    let num_outgoing_edges = out_edges.len();
    for _ in 0..steps {
      // Send current page rank value to all neighbors
      out_edges = out_edges.map_unordered(fn* (edge: Send[Stream[F32]]) {
        edge.send_stream(damping * page_rank / num_outgoing_edges as F32);
        edge
      });
      let page_rank_in;
      (page_rank_in, in_edges) = in_edges.unzip_with(fn* (edge: Recv[Stream[F32]]) {
        let page_rank_in = edge.recv_stream();
        (page_rank_in, edge)
      });
      page_rank = (1.0 - damping) / num_nodes as F32 + page_rank_in.reduce_unordered(Add::add).or_use(
        0.0,
      );
    }
  }

  pub impl show: Show[Node] {
    fn show(&Node({ page_rank, in_edges: _, out_edges: _ })) -> Show {
      Show::Constructor("Node", page_rank.show())
    }
  }
}

struct Graph(List[Node]);

mod Graph {
  pub fn new(num_nodes: N32) -> Graph {
    let initial_page_rank = 1.0 / num_nodes as F32;
    let nodes = [];
    for _ in 0..num_nodes {
      nodes.push_back(Node::new(initial_page_rank));
    }
    Graph(nodes)
  }

  pub fn .connect(&Graph(nodes), a: N32, b: N32) {
    if a != b {
      nodes.at(a).assume().*.link_to(nodes.at(b).assume());
    }
  }

  pub fn .process(&Graph(nodes), steps: N32, damping: F32) {
    let len = nodes.len();
    for &node in &nodes {
      node.process(steps, len, damping);
    }
  }

  pub impl show: Show[Graph];

  pub impl drop: Drop[Graph] {
    fn drop(Graph(nodes)) {
      unsafe::erase(nodes);
    }
  }
}

pub fn main(&io: &IO) {
  let num_nodes = 200;
  let num_edges = 4000;
  let iterations = 1000;
  let graph = Graph::new(num_nodes);

  let rng = Pcg32::seeded("hello world");
  let i = 0;

  while i < num_edges {
    graph.connect(rng.gen_n32() % num_nodes, rng.gen_n32() % num_nodes);
    i += 1;
  }

  let damping = 0.85;
  graph.process(iterations, damping);

  io.println("{graph.show()}");
}

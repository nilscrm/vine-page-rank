
use std::{data::Array, rng::Pcg32};

struct Node {
  incoming_edges: Array[F32],
  outgoing_edges: Array[~F32],
  page_rank: F32,
}

pub mod Node {
  pub fn new(total_num_nodes: N32) -> Node {
    Node({
      incoming_edges: Array::empty,
      outgoing_edges: Array::empty,
      page_rank: 1.0 / total_num_nodes as F32,
    })
  }

  pub fn .process(
    &Node({ incoming_edges, outgoing_edges, page_rank }),
    num_nodes: N32,
    damping: F32,
  ) {
    let (incoming_edges, outgoing_edges) = *&(incoming_edges, outgoing_edges);
    // Send current page rank value to all neighbors
    let s = 0;
    let num_outgoing_edges = outgoing_edges.len();
    outgoing_edges.for_each_independent(fn(~outgoing_edge: ~F32) {
      outgoing_edge = damping * page_rank / num_outgoing_edges as F32;
    });
    // Update page rank based on incoming values
    let new_pr = (1.0 - damping) / num_nodes as F32;
    new_pr = new_pr + incoming_edges.fold_unordered(0.0, F32::add::add);
    page_rank = new_pr;
  }

  pub fn connect(&node1: &Node, &node2: &Node) {
    let incoming: F32;
    let outgoing: ~F32 = move ~incoming;
    node1.outgoing_edges.push_back(outgoing);
    node2.incoming_edges.push_back(incoming);
  }

  pub fn .get_page_rank(&Node({ incoming_edges, outgoing_edges, page_rank })) -> F32 {
    page_rank
  }
}

struct Graph(List[Node]);

mod Graph {
  pub fn new(num_nodes: N32) -> Graph {
    Graph(List::new(num_nodes, Node::new(num_nodes)))
  }

  pub fn .connect(&Graph(nodes), a: N32, b: N32) {
    if a != b {
      Node::connect(nodes.get(a), nodes.get(b))
    }
  }

  pub fn .process(&Graph(nodes), damping: F32) {
    let len = nodes.len();
    let iter = nodes.iter();
    while iter.next() is Some(&node) {
      node.process(len, damping);
    }
  }

  pub fn .print(&Graph(nodes), &io: &IO) {
    let i = 0;
    let iter = nodes.iter();
    while iter.next() is Some(&node) {
      i += 1;
      io.println("Node {i}: {node.page_rank}");
    }
  }
}

pub fn main(&io: &IO) {
  let num_nodes = 200;
  let num_edges = 4000;
  let iterations = 1000;
  let graph = Graph::new(num_nodes);

  let rng = Pcg32::seeded("hello world");
  let i = 0;

  while i < num_edges {
    graph.connect(rng.gen_n32() % num_nodes, rng.gen_n32() % num_nodes);
    i += 1;
  }

  let n = 0;
  let damping = 0.85;
  while n < iterations {
    graph.process(damping);
    n += 1;
  }

  graph.print(&io);
}
